
<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Async Video Downloader</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">

<style>
body { 
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  padding: 10px; 
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
  min-height: 100vh;
  margin: 0;
}

@media (max-width: 768px) {
  body {
    padding: 5px;
  }
}

/* Counter Cards */
.counter-card {
  padding: 15px 20px;
  border-radius: 12px;
  text-align: center;
  color: white;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  transition: all 0.3s ease;
  min-width: 100px;
  flex: 1;
}

@media (max-width: 768px) {
  .counter-card {
    padding: 12px 15px;
    min-width: 80px;
  }
}

.counter-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.counter-number {
  font-size: 2em;
  font-weight: bold;
  margin-bottom: 5px;
  text-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

@media (max-width: 768px) {
  .counter-number {
    font-size: 1.5em;
  }
}

.counter-label {
  font-size: 0.9em;
  opacity: 0.9;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 1px;
}

/* Task Cards */
.task { 
  background: white;
  border: none;
  padding: 15px;
  margin: 8px 0;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.08);
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

@media (max-width: 768px) {
  .task {
    padding: 12px;
    margin: 6px 0;
  }
}

.task::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: #ddd;
  transition: all 0.3s ease;
}

.task.downloading::before { background: #2196f3; }
.task.completed::before { background: #4caf50; }
.task.error::before { background: #f44336; }
.task.pending::before { background: #ff9800; }

.task:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.12);
}

.bar { 
  width: 100%; 
  background: #f0f0f0; 
  height: 8px; 
  border-radius: 10px; 
  overflow: hidden; 
  margin-top: 12px;
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
}

.bar > .fill { 
  height: 100%; 
  width: 0; 
  border-radius: 10px;
  transition: width 0.8s ease, background 0.3s ease;
  position: relative;
}

.bar > .fill::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.meta { 
  font-size: 13px; 
  color: #666; 
  line-height: 1.4;
}

/* Status badges */
.status-badge {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.status-badge.downloading { 
  background: rgba(33, 150, 243, 0.1); 
  color: #2196f3; 
  border: 1px solid rgba(33, 150, 243, 0.2);
}

.status-badge.completed { 
  background: rgba(76, 175, 80, 0.1); 
  color: #4caf50; 
  border: 1px solid rgba(76, 175, 80, 0.2);
}

.status-badge.error { 
  background: rgba(244, 67, 54, 0.1); 
  color: #f44336; 
  border: 1px solid rgba(244, 67, 54, 0.2);
}

.status-badge.pending { 
  background: rgba(255, 152, 0, 0.1); 
  color: #ff9800; 
  border: 1px solid rgba(255, 152, 0, 0.2);
}

/* Form styling */
form {
  background: white;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.08);
  margin-bottom: 15px;
}

@media (max-width: 768px) {
  form {
    padding: 15px;
    margin-bottom: 10px;
  }
}

input[type="text"], input[type="file"] {
  padding: 15px 18px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 16px;
  transition: all 0.3s ease;
  background: #fafafa;
  width: 100%;
  box-sizing: border-box;
}

@media (max-width: 768px) {
  input[type="text"], input[type="file"] {
    padding: 18px 20px;
    font-size: 18px;
  }
}

input[type="text"]:focus, input[type="file"]:focus {
  outline: none;
  border-color: #2196f3;
  background: white;
  box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
}

button {
  padding: 15px 25px;
  border: none;
  border-radius: 8px;
  background: linear-gradient(135deg, #2196f3, #1976d2);
  color: white;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 16px;
  min-height: 50px;
}

@media (max-width: 768px) {
  button {
    padding: 18px 30px;
    font-size: 18px;
    min-height: 60px;
  }
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
}

button:active {
  transform: translateY(0);
}

/* Animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.task {
  animation: fadeInUp 0.5s ease;
}

/* Pulse animation for downloading */
@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(33, 150, 243, 0); }
  100% { box-shadow: 0 0 0 0 rgba(33, 150, 243, 0); }
}

.task.downloading {
  animation: fadeInUp 0.5s ease, pulse 2s infinite;
}

/* Circular Statistics */
.stat-circle {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

@media (max-width: 768px) {
  .stat-circle {
    width: 80px;
    height: 80px;
  }
}

.stat-circle:hover {
  transform: scale(1.05);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.stat-circle::before {
  content: '';
  position: absolute;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  background: white;
  z-index: 1;
}

@media (max-width: 768px) {
  .stat-circle::before {
    width: 60px;
    height: 60px;
  }
}

.stat-content {
  position: relative;
  z-index: 2;
  text-align: center;
  color: #333;
}

.stat-number {
  font-size: 1.5em;
  font-weight: bold;
  margin-bottom: 4px;
  color: #333;
}

@media (max-width: 768px) {
  .stat-number {
    font-size: 1.2em;
  }
}

.stat-label {
  font-size: 0.8em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  color: #666;
}

/* Animated Title Styles */
.animated-title {
  text-align: center;
  font-size: 2.5em;
  font-weight: 700;
  color: #2c3e50;
  margin: 20px 0 30px 0;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
  position: relative;
  animation: titleGlow 3s ease-in-out infinite alternate;
}

@media (max-width: 768px) {
  .animated-title {
    font-size: 1.8em;
    margin: 15px 0 20px 0;
  }
}

.animated-title::after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 50%;
  transform: translateX(-50%);
  width: 100px;
  height: 4px;
  background: linear-gradient(90deg, #667eea, #764ba2);
  border-radius: 2px;
  animation: underlineGlow 2s ease-in-out infinite alternate;
}

@keyframes titleGlow {
  0% { 
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1), 0 0 10px rgba(102, 126, 234, 0.3);
    transform: scale(1);
  }
  100% { 
    text-shadow: 2px 2px 4px rgba(0,0,0,0.1), 0 0 20px rgba(118, 75, 162, 0.6);
    transform: scale(1.02);
  }
}

@keyframes underlineGlow {
  0% { box-shadow: 0 0 5px rgba(102, 126, 234, 0.5); }
  100% { box-shadow: 0 0 20px rgba(118, 75, 162, 0.8); }
}

.section-title {
  text-align: center;
  font-size: 1.5em;
  font-weight: 600;
  color: #333;
  margin: 30px 0 15px 0;
  position: relative;
  padding: 10px 0;
}

@media (max-width: 768px) {
  .section-title {
    font-size: 1.3em;
    margin: 20px 0 10px 0;
  }
}

.section-title::before {
  content: '';
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 3px;
  background: linear-gradient(90deg, #2196f3, #4caf50);
  border-radius: 2px;
}

.section-title::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 40px;
  height: 2px;
  background: linear-gradient(90deg, #ff9800, #f44336);
  border-radius: 1px;
}

/* Character animation keyframes */
@keyframes charFadeIn {
  0% {
    opacity: 0;
    transform: translateY(20px) rotateX(90deg);
  }
  50% {
    opacity: 0.5;
    transform: translateY(10px) rotateX(45deg);
  }
  100% {
    opacity: 1;
    transform: translateY(0) rotateX(0deg);
  }
}

@keyframes charPulse {
  0%, 100% {
    transform: scale(1);
    text-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
  }
  50% {
    transform: scale(1.1);
    text-shadow: 0 0 15px rgba(118, 75, 162, 0.6);
  }
}

.char {
  display: inline-block;
  animation: charFadeIn 0.6s ease-out forwards, charPulse 2s ease-in-out infinite;
  opacity: 0;
  animation-delay: var(--char-delay, 0s);
}
</style>
<style>
body {
  font-family: "Inter", Arial, sans-serif;
  background: #f6f7fb;
  padding: 20px;
  color: #333;
}

/* container for all tasks */
#tasks {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 12px;
  margin-top: 15px;
}

@media (max-width: 768px) {
  #tasks {
    grid-template-columns: 1fr;
    gap: 8px;
  }
}

/* each task card */
.task {
  background: #fff;
  border-radius: 10px;
  padding: 14px 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.07);
  transition: transform 0.25s ease, box-shadow 0.25s ease, border 0.25s ease;
  border: 2px solid transparent;
  display: block !important;
  opacity: 1 !important;
  visibility: visible !important;
  margin: 8px 0;
}

@media (max-width: 768px) {
  .task {
    padding: 12px 14px;
  }
}

.task:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 14px rgba(0,0,0,0.12);
  border-color: #2196f3;
}

/* title and status */
.task-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.task-header b {
  font-size: 15px;
  color: #222;
  word-break: break-all;
}

.task .meta {
  font-size: 13px;
  color: #555;
}

/* progress bar */
.bar {
  width: 100%;
  background: #eee;
  height: 10px;
  border-radius: 50px;
  overflow: hidden;
  margin-top: 8px;
  position: relative;
}

.bar > .fill {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #2196f3, #4caf50);
  border-radius: 50px;
  transition: width 0.8s ease, background-color 0.3s ease;
  will-change: width, background-color;
}

/* status colors */
.status-completed { color: #4caf50; }
.status-downloading { color: #2196f3; }
.status-error { color: #f44336; }
.status-pending { color: #999; }

/* smooth fade-in animation */
.task {
  opacity: 0;
  transform: translateY(10px);
  animation: fadeIn 0.5s forwards;
}
@keyframes fadeIn {
  to { opacity: 1; transform: translateY(0); }
}
/* --- Top-right buttons --- */
#top-controls {
  position: fixed;
  top: 10px;
  right: 10px;
  display: flex;
  gap: 8px;
  z-index: 1000;
}

#top-controls button {
  background: rgba(255,255,255,0.95);
  border: none;
  border-radius: 12px;
  font-size: 24px;
  padding: 12px 16px;
  cursor: pointer;
  transition: all 0.3s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  min-width: 50px;
  min-height: 50px;
  display: flex;
  align-items: center;
  justify-content: center;
}

@media (max-width: 768px) {
  #top-controls {
    top: 5px;
    right: 5px;
    gap: 6px;
  }
  
  #top-controls button {
    font-size: 28px;
    padding: 15px 20px;
    min-width: 60px;
    min-height: 60px;
    border-radius: 15px;
  }
}

#top-controls button:hover {
  background: #2196f3;
  color: white;
}

/* --- Settings window --- */
#settingsWindow {
  position: fixed;
  top: 80px;
  right: 20px;
  width: 350px;
  max-width: calc(100vw - 40px);
  background: white;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.2);
  padding: 25px;
  z-index: 999;
  transition: all 0.3s ease;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
}

@media (max-width: 768px) {
  #settingsWindow {
    top: 80px;
    right: 10px;
    left: 10px;
    width: auto;
    max-width: none;
    padding: 20px;
    border-radius: 20px;
  }
}

#settingsWindow.hidden {
  display: none;
}

body.dark-mode {
  background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
  color: #ddd;
}

body.dark-mode .task {
  background: #2a2a2a;
  color: #eee;
  border-color: #444;
}

body.dark-mode button {
  background: linear-gradient(135deg, #333, #444);
  color: #eee;
}

body.dark-mode input {
  background: #333;
  color: #eee;
  border-color: #555;
}

body.dark-mode form {
  background: #2a2a2a;
}

body.dark-mode #settingsWindow {
  background: #2a2a2a;
  color: #eee;
}

body.dark-mode .stat-circle::before {
  background: #2a2a2a;
}

body.dark-mode .stat-content {
  color: #eee;
}

body.dark-mode .stat-number {
  color: #eee;
}

body.dark-mode .stat-label {
  color: #ccc;
}

body.dark-mode .animated-title {
  color: #eee;
}

body.dark-mode .section-title {
  color: #eee;
}

body.dark-mode #top-controls button {
  background: rgba(42, 42, 42, 0.95);
  color: #eee;
}

</style>

</head>
<body>
<h1 class="animated-title" id="mainTitle">Async Video Downloader</h1>
<!-- Top-right buttons -->
<div id="top-controls">
    <button id="darkModeToggle" title="Toggle Dark Mode">üåô</button>
    <button id="settingsButton" title="Settings">‚öôÔ∏è</button>
  </div>
  
  <!-- Professional Settings Dashboard -->
  <div id="settingsWindow" class="hidden">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h3 style="margin: 0; color: #333; font-size: 1.4em;">‚öôÔ∏è Settings Dashboard</h3>
      <button id="closeSettings" style="background: #f44336; padding: 8px 12px; font-size: 14px;">‚úï</button>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">üìÅ Download Folder</label>
      <input type="text" id="downloadFolder" placeholder="./downloads" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
      <small style="color: #666; font-size: 12px;">Path where downloaded files will be saved</small>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">üöÄ Max Concurrent Downloads</label>
      <input type="number" id="maxConcurrent" min="1" max="10" value="2" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
      <small style="color: #666; font-size: 12px;">Number of downloads running simultaneously (1-10)</small>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">üîÑ Max Retry Attempts</label>
      <input type="number" id="maxRetries" min="1" max="20" value="10" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
      <small style="color: #666; font-size: 12px;">Maximum number of retry attempts for failed downloads</small>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">‚è±Ô∏è Download Timeout (seconds)</label>
      <input type="number" id="downloadTimeout" min="30" max="300" value="60" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
      <small style="color: #666; font-size: 12px;">Timeout for individual download requests</small>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #555;">üì¶ Chunk Size (KB)</label>
      <input type="number" id="chunkSize" min="16" max="1024" value="64" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
      <small style="color: #666; font-size: 12px;">Size of data chunks for downloading</small>
    </div>
    
    <div style="margin-bottom: 20px;">
      <label style="display: flex; align-items: center; cursor: pointer;">
        <input type="checkbox" id="autoDarkMode" style="margin-right: 10px; transform: scale(1.2);">
        <span style="font-weight: 600; color: #555;">üåô Auto Dark Mode</span>
      </label>
      <small style="color: #666; font-size: 12px; margin-left: 25px;">Automatically switch to dark mode based on system preference</small>
    </div>
    
    <div style="display: flex; gap: 10px; margin-top: 25px;">
      <button id="saveSettings" style="flex: 1; background: linear-gradient(135deg, #4caf50, #45a049); padding: 15px; font-size: 16px; font-weight: 600;">üíæ Save Settings</button>
      <button id="resetSettings" style="flex: 1; background: linear-gradient(135deg, #ff9800, #f57c00); padding: 15px; font-size: 16px; font-weight: 600;">üîÑ Reset</button>
    </div>
    
    <div id="settingsStatus" style="margin-top: 15px; padding: 10px; border-radius: 8px; text-align: center; font-weight: 600; display: none;"></div>
  </div>
  
<!-- Circular Statistics -->
<div style="display: flex; justify-content: center; gap: 15px; margin: 20px 0; flex-wrap: wrap;">


  <div class="stat-circle" style="background: conic-gradient(#ff9800 0deg, #ff9800 var(--pending-angle), #e0e0e0 var(--pending-angle), #e0e0e0 360deg);">
    <div class="stat-content">
      <div class="stat-number" id="pending-circle-count">0</div>
      <div class="stat-label">Pending</div>
    </div>
  </div>
  
  <div class="stat-circle" style="background: conic-gradient(#2196f3 0deg, #2196f3 var(--downloading-angle), #e0e0e0 var(--downloading-angle), #e0e0e0 360deg);">
    <div class="stat-content">
      <div class="stat-number" id="downloading-circle-count">0</div>
      <div class="stat-label">Downloading</div>
    </div>
  </div>
  
  <div class="stat-circle" style="background: conic-gradient(#f44336 0deg, #f44336 var(--error-angle), #e0e0e0 var(--error-angle), #e0e0e0 360deg);">
    <div class="stat-content">
      <div class="stat-number" id="error-circle-count">0</div>
      <div class="stat-label">Error</div>
    </div>
  </div>
  
  <div class="stat-circle" style="background: conic-gradient(#4caf50 0deg, #4caf50 var(--done-angle), #e0e0e0 var(--done-angle), #e0e0e0 360deg);">
    <div class="stat-content">
      <div class="stat-number" id="done-circle-count">0</div>
      <div class="stat-label">Done</div>
    </div>
  </div>
</div>

<form id="f" onsubmit="return false;" style="display: flex; gap: 10px; align-items: center;">
<div style="position: relative; flex: 1;">
  <input id="url" placeholder="Paste direct video URL here..." style="width: 100%; padding: 15px 50px 15px 20px; border: 2px solid #e0e0e0; border-radius: 12px; font-size: 16px; background: #fafafa; transition: all 0.3s ease; box-sizing: border-box;color: #000000;" />
  <div style="position: absolute; right: 15px; top: 50%; transform: translateY(-50%); color: #000000; font-size: 18px; color: black;">üîó</div>
</div>
<button id="add" style="min-width: 140px; padding: 15px 20px; background: linear-gradient(135deg, #4caf50, #45a049); border: none; border-radius: 12px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; font-size: 16px; display: flex; align-items: center; gap: 8px;">üì• Add URL</button>
</form>

<style>
/* Enhanced Input Styles */
#url:focus {
  outline: none;
  border-color: #2196f3;
  background: white;
  box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.1);
  transform: translateY(-2px);
}

#url:hover {
  border-color: #1976d2;
  background: white;
}

#add:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
}

#add:active {
  transform: translateY(0);
}

/* File Drop Zone Styles */
#fileDropZone:hover {
  border-color: #1976d2;
  background: linear-gradient(135deg, #f0f7ff, #d1ecf1);
  transform: translateY(-2px);
  box-shadow: 0 4px 15px rgba(33, 150, 243, 0.2);
}

#fileDropZone.dragover {
  border-color: #4caf50;
  background: linear-gradient(135deg, #e8f5e8, #c8e6c9);
  transform: scale(1.02);
}

#uploadBtn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(33, 150, 243, 0.3);
}

#uploadBtn:disabled {
  background: #ccc;
  cursor: not-allowed;
  opacity: 0.6;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  #f {
    flex-direction: column;
    gap: 15px;
  }
  
  #add {
    width: 100%;
    min-width: auto;
  }
  
  #url {
    font-size: 18px;
    padding: 18px 50px 18px 20px;
  }
  
  #fileDropZone {
    padding: 25px 15px;
  }
  
  #fileDropZone div:first-child {
    font-size: 40px;
  }
  
  #uploadBtn {
    font-size: 20px;
    padding: 20px 25px;
    min-height: 70px;
  }
}

/* üåô Dark Mode Styles (override inline styles) */
body.dark-mode #dark-mode {
  background: #121212 !important;
  border: 2px solid #1e1e1e !important;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6) !important;
}

body.dark-mode #dark-mode label {
  color: #e0e0e0 !important;
}

body.dark-mode #fileDropZone {
  border: 3px dashed #4fc3f7 !important;
  background: linear-gradient(135deg, #1a1a1a, #020915) !important;
}

body.dark-mode #fileDropZone:hover {
  background: linear-gradient(135deg, #222, #1565c0) !important;
  border-color: #64b5f6 !important;
}

body.dark-mode #fileDropZone div {
  color: #b0bec5 !important;
}

body.dark-mode #fileDropZone div:nth-child(2) {
  color: #4fc3f7 !important;
}

body.dark-mode #fileInfo {
  background: rgba(46, 125, 50, 0.15) !important;
  border-left: 4px solid #81c784 !important;
}

body.dark-mode #fileInfo div {
  color: #c8e6c9 !important;
}

body.dark-mode #fileName {
  color: #a5d6a7 !important;
}

body.dark-mode #fileSize {
  color: #9e9e9e !important;
}

body.dark-mode #uploadBtn {
  background: linear-gradient(135deg, #2196f3, #1976d2) !important;
  color: #fff !important;
  box-shadow: 0 0 12px rgba(33, 150, 243, 0.4) !important;
}

body.dark-mode #uploadBtn:hover:enabled {
  background: linear-gradient(135deg, #42a5f5, #1e88e5) !important;
  box-shadow: 0 0 20px rgba(66, 165, 245, 0.6) !important;
}

body.dark-mode #uploadBtn:disabled {
  opacity: 0.4 !important;
  background: linear-gradient(135deg, #2c2c2c, #1a1a1a) !important;
  cursor: not-allowed !important;
}
.tooltip {
  position: absolute;
  background: linear-gradient(135deg, #1f1f1f, #2c2c2c);
  color: #f8f8f8;
  padding: 10px 16px;
  border-radius: 10px;
  font-size: 15px;
  font-weight: 500;
  letter-spacing: 0.3px;
  pointer-events: none;
  opacity: 0;
  box-shadow: 0 4px 14px rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(4px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: opacity 0.25s ease, transform 0.25s ease;
  transform: translateY(-8px) scale(0.98);
  z-index: 9999;
  white-space: nowrap;
}
.toast {
  z-index: 9999;
  position: fixed;
  top: 25px;
  right: 30px;
  border-radius: 12px;
  background: #fff;
  padding: 20px 35px 20px 25px;
  box-shadow: 0 6px 20px -5px rgba(0, 0, 0, 0.1);
  overflow: hidden;
  transform: translateX(calc(100% + 30px));
  transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.35);
  display: none; /* hide by default */
}

.toast.active {
  transform: translateX(0%);
  display: flex; /* show when active */
}

.toast .toast-content {
  display: flex;
  align-items: center;
}

.toast-content .check {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 35px;
  min-width: 35px;
  background-color: #2770ff;
  color: #fff;
  font-size: 20px;
  border-radius: 50%;
}

.toast-content .message {
  display: flex;
  flex-direction: column;
  margin: 0 20px;
}

.message .text {
  font-size: 16px;
  font-weight: 400;
  color: #666666;
}

.message .text.text-1 {
  font-weight: 600;
  color: #333;
}

.toast .close {
  position: absolute;
  top: 10px;
  right: 15px;
  padding: 5px;
  cursor: pointer;
  opacity: 0.7;
}

.toast .close:hover {
  opacity: 1;
}

.toast .progress {
  position: absolute;
  bottom: 0;
  left: 0;
  height: 3px;
  width: 100%;
}

.toast .progress:before {
  content: "";
  position: absolute;
  bottom: 0;
  right: 0;
  height: 100%;
  width: 100%;
  background-color: #2770ff;
}


.progress.active:before {
  animation: progress 5s linear forwards;
}

@keyframes progress {
  100% {
    right: 100%;
  }
}

button {
  padding: 12px 20px;
  font-size: 20px;
  outline: none;
  border: none;
  background-color: #2770ff;
  color: #fff;
  border-radius: 6px;
  cursor: pointer;
  transition: 0.3s;
}

button:hover {
  background-color: #2770ff;
}

.toast.active ~ button {
  pointer-events: none;
}

/* Optional arrow under the tooltip */
.tooltip::after {
  content: '';
  position: absolute;
  bottom: -6px;
  left: 50%;
  transform: translateX(-50%);
  border-width: 6px 6px 0 6px;
  border-style: solid;
  border-color: #2c2c2c transparent transparent transparent;
  filter: drop-shadow(0 -1px 1px rgba(0, 0, 0, 0.3));
}


</style>

<h3 class="section-title" >üìÅ Upload .txt file (one URL per line)</h3>
<div id="dark-mode" style="background: white; padding: 25px; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 20px; border: 2px solid #f0f0f0;">
  <div style="margin-bottom: 20px;">
    <label for="fileInput" style="display: block; margin-bottom: 10px; font-weight: 600; color: #555; font-size: 16px; text-align: center;">üìÑ Select Text File</label>
    <div style="position: relative; display: inline-block; width: 100%;">
      <input type="file" id="fileInput" accept=".txt" style="position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; z-index: 2;" />
      <div style="border: 3px dashed #2196f3; border-radius: 12px; padding: 30px 20px; text-align: center; background: linear-gradient(135deg, #f8f9ff, #e3f2fd); transition: all 0.3s ease; cursor: pointer;" id="fileDropZone">
        <div style="font-size: 48px; margin-bottom: 15px;">üìÅ</div>
        <div style="font-size: 18px; font-weight: 600; color: #2196f3; margin-bottom: 8px;">Click to select or drag & drop</div>
        <div style="font-size: 14px; color: #666;">Choose a .txt file containing URLs (one per line)</div>
        <div style="font-size: 12px; color: #999; margin-top: 5px;">Supported formats: .txt</div>
      </div>
    </div>
    <div id="fileInfo" style="margin-top: 15px; padding: 12px; background: #e8f5e8; border-radius: 8px; border-left: 4px solid #4caf50; display: none;">
      <div style="font-weight: 600; color: #2e7d32; margin-bottom: 5px;">üìÑ Selected File:</div>
      <div id="fileName" style="color: #555; font-family: monospace; font-size: 14px;"></div>
      <div id="fileSize" style="color: #666; font-size: 12px; margin-top: 3px;"></div>
    </div>
  </div>
  <button id="uploadBtn" style="width: 100%; padding: 18px 25px; background: linear-gradient(135deg, #2196f3, #1976d2); border: none; border-radius: 12px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; font-size: 18px; display: flex; align-items: center; justify-content: center; gap: 10px; min-height: 60px;" disabled>üì§ Upload & Enqueue URLs</button>
</div>



<!-- Operation Counters 
<div style="display: flex; justify-content: center; gap: 20px; margin: 20px 0; flex-wrap: wrap;">
  <div class="counter-card" style="background: linear-gradient(135deg, #4caf50, #45a049);">
    <div class="counter-number" id="completed-count">0</div>
    <div class="counter-label">Completed</div>
  </div>
  <div class="counter-card" style="background: linear-gradient(135deg, #2196f3, #1976d2);">
    <div class="counter-number" id="in-progress-count">0</div>
    <div class="counter-label">In Progress</div>
  </div>
  <div class="counter-card" style="background: linear-gradient(135deg, #ff9800, #f57c00);">
    <div class="counter-number" id="pending-count">0</div>
    <div class="counter-label">Pending</div>
  </div>
  <div class="counter-card" style="background: linear-gradient(135deg, #f44336, #d32f2f);">
    <div class="counter-number" id="error-count">0</div>
    <div class="counter-label">Errors</div>
  </div>
</div>
-->
<h3 class="section-title">
  <div class="toast ">
  
  <div class="toast-content">
    <i class="fas fa-solid fa-check check"></i>

    <div class="message">
      <span class="text text-1">Success</span>
      <span id="textmsg" class="text text-2">Your changes has been saved</span>
    </div>
  </div>
  <i class="fa-solid fa-xmark close"></i>

  <!-- Remove 'active' class, this is just to show in Codepen thumbnail -->
  <div class="progress "></div>
</div>
  <button id="getsize" class="btn btn-sm btn-danger" style="margin-left: 10px;">size</button>
  Downloads
  <button id="resetDoneBtn" class="btn btn-sm btn-danger" style="margin-left: 10px;">‚ü≥</button>
  

</h3>

<div id="tasks"></div>

<script>

document.getElementById('getsize').addEventListener("click", async () => {
  
  let rx  = null;
  let dirpathx = "./downloads";

 try {
  const res = await fetch("/api/settings");
  const data = await res.json();

  if (data?.download_folder) {
    dirpathx = data.download_folder;
  }
} catch (err) {
  console.error("Failed to load settings:", err);
}
  console.log(rx);
if (rx === null){dirpathx= "./downloads";} 
  try {
  const rss = await fetch("/api/getsize",
  {method: "POST",
   body: JSON.stringify({dirpath: dirpathx})


  }
  
  );
  if (rss.ok) {
  const sizedata = await rss.json();

  const button = document.getElementById("getsize");
  const toast = document.querySelector(".toast");
  const textt = document.getElementById("textmsg");
  const closeIcon = document.querySelector(".close");
  const progress = document.querySelector(".progress");

  let timer1, timer2;

  // Prevent double event listeners
  button.replaceWith(button.cloneNode(true));
  const newButton = document.getElementById("getsize");

  newButton.addEventListener("click", () => {
    textt.innerHTML =
      "Total " +
      dirpathx +
      " folder size is: " +
      sizedata.size;

    toast.style.display = "flex"; // make visible
    toast.classList.add("active");
    progress.classList.add("active");

    // hide after 5s
    timer1 = setTimeout(() => {
      toast.classList.remove("active");
      // wait for animation to finish, then hide
      setTimeout(() => {
        toast.style.display = "none";
      }, 500);
    }, 5000);

    // remove progress class slightly after
    timer2 = setTimeout(() => {
      progress.classList.remove("active");
    }, 5300);
  });

  closeIcon.addEventListener("click", () => {
    toast.classList.remove("active");
    setTimeout(() => {
      toast.style.display = "none";
      progress.classList.remove("active");
    }, 300);
    clearTimeout(timer1);
    clearTimeout(timer2);
  });
}

  }catch (err) {
console.error(err);
  }
});
document.getElementById("resetDoneBtn").addEventListener("click", async () => {
  try {
    const res = await fetch("/api/cleanup_done", { method: "POST" });
    if (res.ok) {
      const data = await res.json();
      showToast(`‚úÖ ${data.removed_count} completed task(s) cleared`, 500,"fixed");
      
    } else {
      showToast("‚ö†Ô∏è Failed to clear completed tasks",500,"fixed");
    }
  } catch (err) {
    showToast("‚ùå Error: " + err.message, 500,"fixed");
  }
});

function showToast(msg, tmm,pos,btt="20px") {
  const toast = document.createElement("div");
  toast.textContent = msg;
  toast.style.position = pos;
  toast.style.bottom = btt;
  toast.style.right = "20px";
  toast.style.background = "#333";
  toast.style.color = "#fff";
  toast.style.padding = "10px 15px";
  toast.style.borderRadius = "5px";
  toast.style.zIndex = "9999";
  toast.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
  toast.style.opacity = "0";
  toast.style.transition = "opacity 0.3s ease";

  document.body.appendChild(toast);
  requestAnimationFrame(() => (toast.style.opacity = "1"));
  setTimeout(() => {
    toast.style.opacity = "0";
    setTimeout(() => toast.remove(), tmm);
    window.location.reload();
    
  }, 3000);
}
function attachTooltip(element, text) {
  let tooltip;

  element.addEventListener("mouseenter", (e) => {
    tooltip = document.createElement("div");
    tooltip.className = "tooltip";
    tooltip.textContent = text;
    document.body.appendChild(tooltip);

    const rect = element.getBoundingClientRect();
    tooltip.style.left = rect.left + window.scrollX + "px";
    tooltip.style.top = rect.top + window.scrollY - 30 + "px";

    requestAnimationFrame(() => {
      tooltip.style.opacity = "1";
      tooltip.style.transform = "translateY(0)";
    });
  });

  element.addEventListener("mouseleave", () => {
    if (tooltip) {
      tooltip.style.opacity = "0";
      tooltip.style.transform = "translateY(-5px)";
      setTimeout(() => tooltip.remove(), 200);
    }
  });
}

// Apply tooltip to button
attachTooltip(document.getElementById("resetDoneBtn"), "Click to clear all completed downloads");

    // --- Dark Mode + Settings ---
const darkModeToggle = document.getElementById('darkModeToggle');
const settingsButton = document.getElementById('settingsButton');
const settingsWindow = document.getElementById('settingsWindow');
const closeSettings = document.getElementById('closeSettings');
const saveSettings = document.getElementById('saveSettings');
const resetSettings = document.getElementById('resetSettings');
const settingsStatus = document.getElementById('settingsStatus');

// Settings form elements
const downloadFolder = document.getElementById('downloadFolder');
const maxConcurrent = document.getElementById('maxConcurrent');
const maxRetries = document.getElementById('maxRetries');
const downloadTimeout = document.getElementById('downloadTimeout');
const chunkSize = document.getElementById('chunkSize');
const autoDarkMode = document.getElementById('autoDarkMode');

darkModeToggle.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
  updateDarkModeIcon();
});

settingsButton.addEventListener('click', () => {
  settingsWindow.classList.toggle('hidden');
  if (!settingsWindow.classList.contains('hidden')) {
    loadSettings();
  }
});

closeSettings.addEventListener('click', () => {
  settingsWindow.classList.add('hidden');
});

// Load settings from server
async function loadSettings() {
  try {
    const response = await fetch('/api/settings');
    const settings = await response.json();
    
    downloadFolder.value = settings.download_folder || './downloads';
    maxConcurrent.value = settings.max_concurrent || 2;
    maxRetries.value = settings.max_retries || 10;
    downloadTimeout.value = settings.download_timeout || 60;
    chunkSize.value = settings.chunk_size || 64;
    autoDarkMode.checked = settings.auto_dark_mode || false;
  } catch (error) {
    console.error('Failed to load settings:', error);
    showSettingsStatus('Failed to load settings', 'error');
  }
}

// Save settings to server
saveSettings.addEventListener('click', async () => {
  const settings = {
    download_folder: downloadFolder.value,
    max_concurrent: parseInt(maxConcurrent.value),
    max_retries: parseInt(maxRetries.value),
    download_timeout: parseInt(downloadTimeout.value),
    chunk_size: parseInt(chunkSize.value),
    auto_dark_mode: autoDarkMode.checked
  };
  localStorage.setItem("stDir", settings.download_folder);
  console.log(settings.download_folder);
  try {
    const response = await fetch('/api/settings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(settings)
    });
    
    const result = await response.json();
    if (result.success) {
      showSettingsStatus('Settings saved successfully!', 'success');
      // Apply settings immediately
      applySettings(settings);
    } else {
      showSettingsStatus('Failed to save settings: ' + result.error, 'error');
    }
  } catch (error) {
    console.error('Failed to save settings:', error);
    showSettingsStatus('Failed to save settings', 'error');
  }
});

// Reset settings to defaults
resetSettings.addEventListener('click', () => {
  downloadFolder.value = './downloads';
  maxConcurrent.value = 2;
  maxRetries.value = 10;
  downloadTimeout.value = 60;
  chunkSize.value = 64;
  autoDarkMode.checked = false;
  showSettingsStatus('Settings reset to defaults', 'info');
});

// Show status message
function showSettingsStatus(message, type) {
  settingsStatus.textContent = message;
  settingsStatus.className = '';
  settingsStatus.style.display = 'block';
  
  if (type === 'success') {
    settingsStatus.style.background = '#d4edda';
    settingsStatus.style.color = '#155724';
    settingsStatus.style.border = '1px solid #c3e6cb';
  } else if (type === 'error') {
    settingsStatus.style.background = '#f8d7da';
    settingsStatus.style.color = '#721c24';
    settingsStatus.style.border = '1px solid #f5c6cb';
  } else {
    settingsStatus.style.background = '#d1ecf1';
    settingsStatus.style.color = '#0c5460';
    settingsStatus.style.border = '1px solid #bee5eb';
  }
  
  setTimeout(() => {
    settingsStatus.style.display = 'none';
  }, 3000);
}

// Apply settings to the application
function applySettings(settings) {
  // Update dark mode if auto dark mode is enabled
  if (settings.auto_dark_mode) {
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (prefersDark) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
  }
}

// Update dark mode icon
function updateDarkModeIcon() {
  const isDark = document.body.classList.contains('dark-mode');
  darkModeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
}

// Remember user's dark mode preference
document.addEventListener('DOMContentLoaded', () => {
  if (localStorage.getItem('darkMode') === 'true') {
    document.body.classList.add('dark-mode');
  }
  updateDarkModeIcon();
});

// Listen for system dark mode changes
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
  if (autoDarkMode && autoDarkMode.checked) {
    if (e.matches) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
    updateDarkModeIcon();
  }
});

// Character-by-character animation for the main title
function animateTitle() {
  const titleElement = document.getElementById('mainTitle');
  if (!titleElement) return;
  
  const text = titleElement.textContent;
  titleElement.innerHTML = '';
  
  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const span = document.createElement('span');
    span.className = 'char';
    span.textContent = char === ' ' ? '\u00A0' : char; // Use non-breaking space for spaces
    span.style.setProperty('--char-delay', `${i * 0.1}s`);
    titleElement.appendChild(span);
  }
}

// Initialize title animation when page loads
document.addEventListener('DOMContentLoaded', function() {
  animateTitle();
});

function formatBytes(bytes) {
  if (bytes === 0 || bytes == null) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function updateCounters(data) {
  const counts = {
    completed: 0,
    downloading: 0,
    pending: 0,
    error: 0
  };
  
  Object.values(data).forEach(task => {
    if (task.status === 'completed') counts.completed++;
    else if (task.status === 'downloading' || task.status.includes('retrying')) counts.downloading++;
    else if (task.status === 'pending' || task.status === 'queued') counts.pending++;
    else if (task.status === 'error') counts.error++;
  });
  
  // Update rectangular counters (if they exist)
  const completedCountEl = document.getElementById('completed-count');
  const inProgressCountEl = document.getElementById('in-progress-count');
  const pendingCountEl = document.getElementById('pending-count');
  const errorCountEl = document.getElementById('error-count');
  
  if (completedCountEl) completedCountEl.textContent = counts.completed;
  if (inProgressCountEl) inProgressCountEl.textContent = counts.downloading;
  if (pendingCountEl) pendingCountEl.textContent = counts.pending;
  if (errorCountEl) errorCountEl.textContent = counts.error;
  
  // Update circular counters (if they exist)
  const pendingCircleEl = document.getElementById('pending-circle-count');
  const downloadingCircleEl = document.getElementById('downloading-circle-count');
  const errorCircleEl = document.getElementById('error-circle-count');
  const doneCircleEl = document.getElementById('done-circle-count');
  
  if (pendingCircleEl) pendingCircleEl.textContent = counts.pending;
  if (downloadingCircleEl) downloadingCircleEl.textContent = counts.downloading;
  if (errorCircleEl) errorCircleEl.textContent = counts.error;
  if (doneCircleEl) doneCircleEl.textContent = counts.completed;
  
  // Calculate total for percentage calculations
  const total = counts.pending + counts.downloading + counts.error + counts.completed;
  
  // Update circular progress angles
  if (total > 0) {
    const pendingAngle = (counts.pending / total) * 360;
    const downloadingAngle = (counts.downloading / total) * 360;
    const errorAngle = (counts.error / total) * 360;
    const doneAngle = (counts.completed / total) * 360;
    
    document.documentElement.style.setProperty('--pending-angle', `${pendingAngle}deg`);
    document.documentElement.style.setProperty('--downloading-angle', `${downloadingAngle}deg`);
    document.documentElement.style.setProperty('--error-angle', `${errorAngle}deg`);
    document.documentElement.style.setProperty('--done-angle', `${doneAngle}deg`);
  } else {
    // Reset to 0 if no tasks
    document.documentElement.style.setProperty('--pending-angle', '0deg');
    document.documentElement.style.setProperty('--downloading-angle', '0deg');
    document.documentElement.style.setProperty('--error-angle', '0deg');
    document.documentElement.style.setProperty('--done-angle', '0deg');
  }
}
// Keep track of existing task elements
const taskElements = new Map();
let renderPending = false;

// Smooth progress transitions
const style = document.createElement('style');
style.textContent = `
.bar .fill {
  transition: width 0.3s linear;
}
.task {
  transition: background 0.3s ease, opacity 0.3s ease;
}
.status-badge {
  transition: background 0.3s ease, color 0.3s ease;
}
`;
document.head.appendChild(style);

// Schedule render updates to prevent flicker
function scheduleRender(data) {
  if (renderPending) return;
  renderPending = true;
  requestAnimationFrame(() => {
    renderTasks(data);
    renderPending = false;
  });
}

function renderTasks(data) {
  const container = document.getElementById('tasks');
  if (!container) {
    console.error('Tasks container not found!');
    return;
  }

  // Update counters
  updateCounters(data);

  // Sort tasks: downloading/retrying first, then by status
  const arr = Object.values(data).sort((a, b) => {
    const aActive = a.status === 'downloading' || a.status.includes('retrying');
    const bActive = b.status === 'downloading' || b.status.includes('retrying');
    if (aActive && !bActive) return -1;
    if (!aActive && bActive) return 1;
    const priority = { downloading: 1, retrying: 1, error: 2, pending: 3, queued: 3, completed: 4 };
    return (priority[a.status] || 5) - (priority[b.status] || 5);
  });

  // Remove deleted tasks
  const currentTaskIds = new Set(arr.map(t => t.id));
  for (const [taskId, el] of taskElements) {
    if (!currentTaskIds.has(taskId)) {
      el.remove();
      taskElements.delete(taskId);
    }
  }

  // Reuse existing nodes or create new ones
  const fragment = document.createDocumentFragment();

  for (const t of arr) {
    let el = taskElements.get(t.id);

    if (!el) {
      // --- CREATE NEW ELEMENT ---
      el = document.createElement('div');
      el.className = `task ${t.status}`;
      el.setAttribute('data-task-id', t.id);

      let statusClass = 'pending';
      if (t.status === 'completed') statusClass = 'completed';
      else if (t.status === 'downloading' || t.status.includes('retrying')) statusClass = 'downloading';
      else if (t.status === 'error') statusClass = 'error';
      
      el.innerHTML = `
        <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <div style="display: flex; align-items: center; gap: 12px;">
            <div>
              <div class="task-filename" style="font-size: 16px; font-weight: 600; color: #ccc; margin-bottom: 4px;">
                ${t.filename ? t.filename.split('/').pop() : '(pending)'}
              </div>
              <div class="meta">
                ID: <span style="font-family:monospace; background: #333; color:#ddd; padding: 2px 6px; border-radius: 4px;">${t.id}</span>
              </div>
            </div>
          </div>
          <span class="status-badge ${statusClass}">${t.status}</span>
        </div>

        <div class="meta" style="margin-bottom: 12px;">
          <a href="${t.url}" target="_blank" rel="noreferrer noopener" style="color:#4fc3f7; text-decoration:none; font-weight:500;">
            üîó View Source
          </a>
          <span class="retry-info" style="margin-left: 12px; color: #ff9800; font-weight: 500;"></span>
        </div>

        <div class="bar" style="background:#222; border-radius:6px; overflow:hidden; height:10px;">
          <div class="fill" style="width: ${t.progress || 0}%; background: ${t.status==='completed' ? '#4caf50' : t.status==='downloading' || t.status.includes('retrying') ? '#2196f3' : t.status==='error' ? '#f44336' : '#ff9800'}; height:100%;"></div>
        </div>

        <div class="meta" style="margin-top: 12px; display: flex; justify-content: space-between; align-items: center;">
          <div class="progress-info" style="color:#ccc;">
            <strong>${t.progress !== null && t.progress !== undefined ? t.progress + '%' : '?'}</strong> ‚Ä¢ 
            Downloaded: <strong>${formatBytes(t.downloaded_bytes)}</strong> ‚Ä¢ 
            Total: <strong>${formatBytes(t.total_bytes)}</strong>
          </div>
          <div class="active-indicator" style="color: #4fc3f7; font-size: 12px;"></div>
        </div>

        <div class="error-message" style="margin-top: 12px; padding: 12px; background: #3b0b0b; border-left: 4px solid #f44336; border-radius: 4px; color: #f44336; font-weight: 500; display: none;"></div>
      `;

      taskElements.set(t.id, el);
      container.appendChild(el);

      //fragment.appendChild(el);
    } else {
      // --- UPDATE EXISTING ELEMENT ---
      updateTaskElement(el, t);
      
    }

    //fragment.appendChild(el);
  }

  // Only re-append (no destruction)
  
  
}

function updateTaskElement(el, t) {
  const fill = el.querySelector('.fill');
  const statusBadge = el.querySelector('.status-badge');
  const errorBox = el.querySelector('.error-message');
  const progressInfo = el.querySelector('.progress-info strong');

  // Update progress bar width
  if (fill) {
    fill.style.width = `${t.progress || 0}%`;
    fill.style.background =
      t.status === 'completed'
        ? '#4caf50'
        : t.status === 'downloading' || t.status.includes('retrying')
        ? '#2196f3'
        : t.status === 'error'
        ? '#f44336'
        : '#ff9800';
  }

  // Update percentage text
  if (progressInfo) {
    progressInfo.textContent = `${t.progress ?? '?'}%`;
  }

  // Update status badge if changed
  if (statusBadge && statusBadge.textContent !== t.status) {
    statusBadge.textContent = t.status;
    statusBadge.className = `status-badge ${t.status}`;
  }

  // Show error message if exists
  if (errorBox) {
    if (t.status === 'error' && t.error_message) {
      errorBox.style.display = 'block';
      errorBox.textContent = t.error_message;
    } else {
      errorBox.style.display = 'none';
    }
  }
}


function updateTaskElement(el, t) {
  // Update progress bar width smoothly
  const fill = el.querySelector('.fill');
  if (fill) {
    const currentWidth = fill.style.width;
    const newWidth = `${t.progress || 0}%`;
    
    // Only update if width actually changed to prevent unnecessary repaints
    if (currentWidth !== newWidth) {
      fill.style.width = newWidth;
    }
    
    // Update background color if status changed
    const newBackground = t.status === 'completed' ? '#4caf50' :
      t.status === 'downloading' || t.status.includes('retrying') ? '#2196f3' :
      t.status === 'error' ? '#f44336' : '#ff9800';
    
    if (fill.style.background !== newBackground) {
      fill.style.background = newBackground;
    }
  }

  // Update status badge without resetting animation
  const badge = el.querySelector('.status-badge');
  if (badge && badge.textContent !== t.status) {
    badge.textContent = t.status;
    const newStatusClass = t.status === 'completed' ? 'completed' :
      t.status === 'downloading' || t.status.includes('retrying') ? 'downloading' :
      t.status === 'error' ? 'error' : 'pending';
    
    badge.className = `status-badge ${newStatusClass}`;
  }

  // Update progress text efficiently
  const info = el.querySelector('.progress-info');
  if (info) {
    const progressText = `${t.progress !== null && t.progress !== undefined ? t.progress + '%' : '?'}`;
    const downloadedText = formatBytes(t.downloaded_bytes);
    const totalText = formatBytes(t.total_bytes);
    const newContent = `<strong>${progressText}</strong> ‚Ä¢ Downloaded: <strong>${downloadedText}</strong> ‚Ä¢ Total: <strong>${totalText}</strong>`;
    
    // Only update if content actually changed
    if (info.innerHTML !== newContent) {
      info.innerHTML = newContent;
    }
  }

  // Update filename if it changed
  const filenameEl = el.querySelector('.task-filename');
  if (filenameEl) {
    const newFilename = t.filename ? t.filename.split('/').pop() : '(pending)';
    if (filenameEl.textContent !== newFilename) {
      filenameEl.textContent = newFilename;
    }
  }

  // Update error message visibility efficiently
  const errorBox = el.querySelector('.error-message');
  if (errorBox) {
    if (t.error) {
      const errorText = `Error: ${t.error}`;
      if (errorBox.textContent !== errorText) {
        errorBox.textContent = errorText;
      }
      if (errorBox.style.display !== 'block') {
        errorBox.style.display = 'block';
      }
    } else {
      if (errorBox.style.display !== 'none') {
        errorBox.style.display = 'none';
      }
    }
  }

  // Update task class for styling
  const newTaskClass = `task ${t.status}`;
  if (el.className !== newTaskClass) {
    el.className = newTaskClass;
  }
}

// Enhanced File upload functionality with drag & drop
document.addEventListener('DOMContentLoaded', function() {
  const uploadBtn = document.getElementById('uploadBtn');
  const fileInput = document.getElementById('fileInput');
  const fileDropZone = document.getElementById('fileDropZone');
  const fileInfo = document.getElementById('fileInfo');
  const fileName = document.getElementById('fileName');
  const fileSize = document.getElementById('fileSize');
  
  if (!uploadBtn || !fileInput || !fileDropZone) {
    console.error('Required elements not found');
    return;
  }
  
  // Format file size
  function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  // Update file info display
  function updateFileInfo(file) {
    if (file) {
      fileName.textContent = file.name;
      fileSize.textContent = formatFileSize(file.size);
      fileInfo.style.display = 'block';
      uploadBtn.disabled = false;
      
      // Update drop zone text
      fileDropZone.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">‚úÖ</div>
        <div style="font-size: 18px; font-weight: 600; color: #4caf50; margin-bottom: 8px;">File Selected!</div>
        <div style="font-size: 14px; color: #666;">${file.name}</div>
        <div style="font-size: 12px; color: #999; margin-top: 5px;">Click to change file</div>
      `;
    } else {
      fileInfo.style.display = 'none';
      uploadBtn.disabled = true;
      
      // Reset drop zone text
      fileDropZone.innerHTML = `
        <div style="font-size: 48px; margin-bottom: 15px;">üìÅ</div>
        <div style="font-size: 18px; font-weight: 600; color: #2196f3; margin-bottom: 8px;">Click to select or drag & drop</div>
        <div style="font-size: 14px; color: #666;">Choose a .txt file containing URLs (one per line)</div>
        <div style="font-size: 12px; color: #999; margin-top: 5px;">Supported formats: .txt</div>
      `;
    }
  }
  
  // Handle file selection
  function handleFile(file) {
    if (!file) return;
    
    if (!file.name.toLowerCase().endsWith('.txt')) {
      alert('Please select a .txt file');
      return;
    }
    
    updateFileInfo(file);
  }
  
  // File input change handler
  fileInput.addEventListener('change', function() {
    handleFile(fileInput.files[0]);
  });
  
  // Drag and drop handlers
  fileDropZone.addEventListener('dragover', function(e) {
    e.preventDefault();
    fileDropZone.classList.add('dragover');
  });
  
  fileDropZone.addEventListener('dragleave', function(e) {
    e.preventDefault();
    fileDropZone.classList.remove('dragover');
  });
  
  fileDropZone.addEventListener('drop', function(e) {
    e.preventDefault();
    fileDropZone.classList.remove('dragover');
    
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      fileInput.files = files;
      handleFile(files[0]);
    }
  });
  
  // Click handler for drop zone
  fileDropZone.addEventListener('click', function() {
    fileInput.click();
  });
  
  // Upload button handler
  uploadBtn.addEventListener('click', async function(e) {
    e.preventDefault();
    
    const file = fileInput.files[0];
    
    if (!file) {
      alert('Please select a .txt file first');
      return;
    }
    
    try {
      console.log('Reading file:', file.name);
      const text = await file.text();
      console.log('File content length:', text.length);
      
      // Parse URLs from text file
      const urls = text.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0 && (line.startsWith('http://') || line.startsWith('https://')));
      
      console.log('Found URLs:', urls.length);
      console.log('URLs array:', urls);
      
      if (urls.length === 0) {
        alert('No valid URLs found in the file. Each line should contain a URL starting with http:// or https://');
        return;
      }
      
      // Show loading state
      const originalText = uploadBtn.innerHTML;
      uploadBtn.innerHTML = '‚è≥ Processing...';
      uploadBtn.disabled = true;
      
      console.log('Sending URLs array to server:', urls);
      
      // Send URLs array to bulk enqueue endpoint
      const response = await fetch('/bulk_enqueue', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ urls: urls })
      });
      
      const result = await response.json();
      console.log('Server response:', result);
      
      if (result.ok) {
        alert(`‚úÖ Successfully enqueued ${result.count} URLs for download!`);
        fileInput.value = '';
        updateFileInfo(null);
      } else {
        alert(`‚ùå Error: ${result.error}`);
      }
      
    } catch (error) {
      console.error('Error processing file:', error);
      alert('‚ùå Error reading file: ' + error.message);
    } finally {
      // Reset button state
      uploadBtn.innerHTML = "upload more";
      uploadBtn.disabled = false;
    }
  });
  
  // Initialize with no file selected
  updateFileInfo(null);
});

// Add URL functionality
document.addEventListener('DOMContentLoaded', function() {
  const addBtn = document.getElementById('add');
  const urlInput = document.getElementById('url');
  
  if (addBtn && urlInput) {
    addBtn.addEventListener('click', async function(e) {
      e.preventDefault();
      
      const url = urlInput.value.trim();
      
      if (!url) {
        alert('Please enter a URL');
        return;
      }
      
      if (!url.startsWith('http://') && !url.startsWith('https://')) {
        alert('URL must start with http:// or https://');
        return;
      }
      
      // Show loading state
      const originalText = addBtn.innerHTML;
      addBtn.innerHTML = '‚è≥ Adding...';
      addBtn.disabled = true;
      
      try {
        const response = await fetch('/enqueue', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ url: url })
        });
        
        const result = await response.json();
        
        if (result.ok) {
          urlInput.value = '';
          console.log('URL enqueued successfully:', result.id);
        } else {
          alert('Error: ' + result.error);
        }
      } catch (error) {
        console.error('Error enqueuing URL:', error);
        alert('Error adding URL: ' + error.message);
      } finally {
        // Reset button state
        addBtn.innerHTML = originalText;
        addBtn.disabled = false;
      }
    });
    
    // Allow Enter key to submit
    urlInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        addBtn.click();
      }
    });
  }
});
const evtSource = new EventSource('/status');

evtSource.onmessage = function(event) {
  try {
    const data = JSON.parse(event.data);
    renderTasks(data); // your existing UI update function
  } catch (e) {
    console.error("Stream parse error:", e);
  }
};

evtSource.onerror = function(e) {
  console.warn("Stream connection lost, retrying...");
};

</script>
</body>
</html>